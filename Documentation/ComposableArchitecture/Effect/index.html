<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ComposableArchitecture - Effect</title>
    <link rel="stylesheet" type="text/css" href="/Users/brandon/projects/swift-composable-architecture/Documentation/ComposableArchitecture/all.css" media="all" />
</head>
<body>
    <header>
        <a href="/Users/brandon/projects/swift-composable-architecture/Documentation/ComposableArchitecture">
            <strong>
                ComposableArchitecture
            </strong>
            <span>Documentation</span>
        </a>
        <sup>Beta</sup>
    </header>

    <!--
    <form class="search">
        <input type="search" placeholder="Search" />
    </form>
    -->

    <nav>
        <div class="wrapper">
            <h2>On This Page</h2>
            <ol><li><a href="#relationships">Relationships</a><ul><li><a href="#relationships">Nested Types</a></li><li><a href="#relationships">Conforms To</a></li></ul></li><li><a href="#initializers">Initializers</a><ul><li class="initializer"><a href="#effect.init(_:)">init(_:​)</a></li><li class="initializer"><a href="#effect.init(value:)">init(value:​)</a></li><li class="initializer"><a href="#effect.init(error:)">init(error:​)</a></li></ul></li><li><a href="#properties">Properties</a><ul><li class="property"><a href="#effect.upstream">upstream</a></li><li class="property"><a href="#effect.none">none</a></li><li class="property"><a href="#effect.debugoutput">debug​Output</a></li></ul></li><li><a href="#methods">Methods</a><ul><li class="method"><a href="#effect.receive(subscriber:)">receive(subscriber:​)</a></li><li class="method"><a href="#effect.future(_:)">future(_:​)</a></li><li class="method"><a href="#effect.result(_:)">result(_:​)</a></li><li class="method"><a href="#effect.run(_:)">run(_:​)</a></li><li class="method"><a href="#effect.concatenate(_:)">concatenate(_:​)</a></li><li class="method"><a href="#effect.concatenate(_:)">concatenate(_:​)</a></li><li class="method"><a href="#effect.merge(_:)">merge(_:​)</a></li><li class="method"><a href="#effect.merge(_:)">merge(_:​)</a></li><li class="method"><a href="#effect.fireandforget(_:)">fire​And​Forget(_:​)</a></li><li class="method"><a href="#effect.map(_:)">map(_:​)</a></li><li class="method"><a href="#effect.cancellable(id:cancelinflight:)">cancellable(id:​cancel​InFlight:​)</a></li><li class="method"><a href="#effect.cancel(id:)">cancel(id:​)</a></li><li class="method"><a href="#effect.debounce(id:for:scheduler:options:)">debounce(id:​for:​scheduler:​options:​)</a></li><li class="method"><a href="#effect.timer(id:every:tolerance:on:options:)">timer(id:​every:​tolerance:​on:​options:​)</a></li><li class="method"><a href="#effect.async(_:)">async(_:​)</a></li><li class="method"><a href="#effect.throttle(id:for:scheduler:latest:)">throttle(id:​for:​scheduler:​latest:​)</a></li></ul></li></ol>
        </div>
    </nav>

    <main>
        <article>
            <h1>
    <small>Structure</small>
    <code class="name">Effect</code>
</h1>

<html><body><pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">struct</span> <span class="type">Effect</span>&lt;<span class="variable">Output</span>, <span class="variable">Failure</span>: <span class="type">Error</span>&gt;: <span class="type">Publisher</span></code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>The <code>Effect</code> type encapsulates a unit of work that can be run in the outside world, and can feed
data back to the <code>Store</code>. It is the perfect place to do side effects, such as network requests,
saving/loading from disk, creating timers, interacting with dependencies, and more.</p>

</div>
<div class="discussion">
    <p>Effects are returned from reducers so that the <code>Store</code> can perform the effects after the reducer
is done running. It is important to note that <code>Store</code> is not thread safe, and so all effects
must receive values on the same thread, <strong>and</strong> if the store is being used to drive UI then it
must receive values on the main thread.</p>

<p>An effect simply wraps a <code>Publisher</code> value and provides some convenience initializers for
constructing some common types of effects.</p>

</div>
<section id="relationships">
    <h2 hidden>Relationships</h2>
        <figure>
    <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.44.0 (20200408.0750)
 -->
<!-- Pages: 1 -->
<svg width="872pt" height="116pt"
 viewBox="0.00 0.00 872.00 116.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 112)">
<polygon fill="white" stroke="transparent" points="-4,4 -4,-112 868,-112 868,4 -4,4"/>
<!-- Effect -->
<g id="node1" class="node structure current">
<title>Effect</title>
<g id="a_node1"><a xlink:href="/Users/brandon/projects/swift-composable-architecture/Documentation/ComposableArchitecture/Effect" xlink:title="Effect">
<path fill="none" stroke="black" stroke-width="3" d="M513.66,-108C513.66,-108 321.66,-108 321.66,-108 315.66,-108 309.66,-102 309.66,-96 309.66,-96 309.66,-84 309.66,-84 309.66,-78 315.66,-72 321.66,-72 321.66,-72 513.66,-72 513.66,-72 519.66,-72 525.66,-78 525.66,-84 525.66,-84 525.66,-96 525.66,-96 525.66,-102 519.66,-108 513.66,-108"/>
<text text-anchor="middle" x="417.66" y="-86.3" font-family="Menlo" font-size="14.00">Effect</text>
</a>
</g>
</g>
<!-- Publisher -->
<g id="node2" class="node unknown">
<title>Publisher</title>
<path fill="none" stroke="black" d="M289.66,-36C289.66,-36 97.66,-36 97.66,-36 91.66,-36 85.66,-30 85.66,-24 85.66,-24 85.66,-12 85.66,-12 85.66,-6 91.66,0 97.66,0 97.66,0 289.66,0 289.66,0 295.66,0 301.66,-6 301.66,-12 301.66,-12 301.66,-24 301.66,-24 301.66,-30 295.66,-36 289.66,-36"/>
<text text-anchor="middle" x="193.66" y="-14.3" font-family="Menlo" font-size="14.00">Publisher</text>
</g>
<!-- Effect&#45;&gt;Publisher -->
<g id="edge1" class="edge conformsTo">
<title>Effect&#45;&gt;Publisher</title>
<path fill="none" stroke="black" d="M363.15,-71.97C331.44,-62.06 291.3,-49.51 258.05,-39.12"/>
<polygon fill="black" stroke="black" points="259,-35.75 248.41,-36.11 256.92,-42.43 259,-35.75"/>
</g>
<!-- CustomDebugOutputConvertible -->
<g id="node3" class="node protocol">
<title>CustomDebugOutputConvertible</title>
<path fill="none" stroke="black" d="M753.66,-36C753.66,-36 529.66,-36 529.66,-36 523.66,-36 517.66,-30 517.66,-24 517.66,-24 517.66,-12 517.66,-12 517.66,-6 523.66,0 529.66,0 529.66,0 753.66,0 753.66,0 759.66,0 765.66,-6 765.66,-12 765.66,-12 765.66,-24 765.66,-24 765.66,-30 759.66,-36 753.66,-36"/>
<text text-anchor="middle" x="641.66" y="-14.3" font-family="Menlo" font-size="14.00">CustomDebugOutputConvertible</text>
</g>
<!-- Effect&#45;&gt;CustomDebugOutputConvertible -->
<g id="edge2" class="edge conformsTo">
<title>Effect&#45;&gt;CustomDebugOutputConvertible</title>
<path fill="none" stroke="black" d="M472.17,-71.97C503.88,-62.06 544.02,-49.51 577.27,-39.12"/>
<polygon fill="black" stroke="black" points="578.4,-42.43 586.91,-36.11 576.32,-35.75 578.4,-42.43"/>
</g>
</g>
</svg>


    <figcaption hidden>Inheritance graph for Effect.</figcaption>
</figure>
        <h3>Nested Types</h3>
<dl>
    <dt class="structure"><code><a href="/Users/brandon/projects/swift-composable-architecture/Documentation/ComposableArchitecture/Effect_Subscriber">Effect.Subscriber</a></code></dt>
<dd></dd>
</dl>
<h3>Conforms To</h3>
<dl>
    <dt class="protocol"><code><a href="/Users/brandon/projects/swift-composable-architecture/Documentation/ComposableArchitecture/CustomDebugOutputConvertible">CustomDebugOutputConvertible</a></code></dt>
<dd></dd>
<dt class="unknown"><code>Publisher</code></dt>
</dl>
</section>
    <section id="initializers">
        <h2>Initializers</h2>

        <div role="article" class="structure" id="effect.init(_:)">
    <h3>
        <code>init(_:​)</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">init</span>&lt;<span class="variable">P</span>: <span class="type">Publisher</span>&gt;(<span class="keyword">_</span> <span class="variable">publisher</span>: <span class="type">P</span>) <span class="keyword">where</span> <span class="type">P</span>.<span class="type">Output</span> == <span class="type">Output</span>, <span class="type">P</span>.<span class="type">Failure</span> == <span class="type">Failure</span></code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>Initializes an effect that wraps a publisher. Each emission of the wrapped publisher will be
emitted by the effect.</p>

</div>
<div class="discussion">
    <p>This initializer is useful for turning any publisher into an effect. For example:</p>

<html><body><pre class="highlight"><code><span class="variable">Effect</span>(
  <span class="variable">NotificationCenter</span>.<span class="type">default</span>
    .<span class="type">publisher</span>(<span class="variable">for</span>: <span class="type">UIApplication</span>.<span class="type">userDidTakeScreenshotNotification</span>)
)
</code></pre></body></html>
<p>Alternatively, you can use the <code>.eraseToEffect()</code> method that is defined on the <code>Publisher</code>
protocol:</p>

<html><body><pre class="highlight"><code><span class="variable">NotificationCenter</span>.<span class="type">default</span>
  .<span class="type">publisher</span>(<span class="variable">for</span>: <span class="type">UIApplication</span>.<span class="type">userDidTakeScreenshotNotification</span>)
  .<span class="type">eraseToEffect</span>()
</code></pre></body></html>
</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>publisher</th>
    <td><code class="type">P</code></td></td>
    <td><ul>
<li>publisher: A publisher.</li>
</ul>
</td>
</tr>
  </tbody>
</table>
</div>
<div role="article" class="structure" id="effect.init(value:)">
    <h3>
        <code>init(value:​)</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">init</span>(<span class="variable">value</span>: <span class="type">Output</span>)</code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>Initializes an effect that immediately emits the value passed in.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>value</th>
    <td><code class="type">Output</code></td></td>
    <td><ul>
<li>value: The value that is immediately emitted by the effect.</li>
</ul>
</td>
</tr>
  </tbody>
</table>
</div>
<div role="article" class="structure" id="effect.init(error:)">
    <h3>
        <code>init(error:​)</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">init</span>(<span class="variable">error</span>: <span class="type">Failure</span>)</code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>Initializes an effect that immediately fails with the error passed in.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>error</th>
    <td><code class="type">Failure</code></td></td>
    <td><ul>
<li>error: The error that is immediately emitted by the effect.</li>
</ul>
</td>
</tr>
  </tbody>
</table>
</div>
    </section>
    <section id="properties">
        <h2>Properties</h2>

        <div role="article" class="structure" id="effect.upstream">
    <h3>
        <code>upstream</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">let</span> <span class="variable">upstream</span>: <span class="type">AnyPublisher</span>&lt;<span class="type">Output</span>, <span class="type">Failure</span>&gt;</code></pre></body></html>
</div>
<div role="article" class="structure" id="effect.none">
    <h3>
        <code>none</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">var</span> <span class="variable">none</span>: <a href="/Users/brandon/projects/swift-composable-architecture/Documentation/ComposableArchitecture/Effect"><span class="type">Effect</span></a></code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>An effect that does nothing and completes immediately. Useful for situations where you must
return an effect, but you don't need to do anything.</p>

</div>
</div>
<div role="article" class="structure" id="effect.debugoutput">
    <h3>
        <code>debug​Output</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">var</span> <span class="variable">debugOutput</span>: <span class="type">String</span></code></pre></body></html>
</div>
    </section>
    <section id="methods">
        <h2>Methods</h2>

        <div role="article" class="structure" id="effect.receive(subscriber:)">
    <h3>
        <code>receive(subscriber:​)</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">func</span> <span class="function">receive</span>&lt;<span class="variable">S</span>&gt;(<span class="variable">subscriber</span>: <span class="type">S</span>) <span class="keyword">where</span> <span class="type">S</span>: <span class="type">Combine</span>.<span class="type">Subscriber</span>, <span class="type">Failure</span> == <span class="type">S</span>.<span class="type">Failure</span>, <span class="type">Output</span> == <span class="type">S</span>.<span class="type">Input</span></code></pre></body></html>
</div>
<div role="article" class="structure" id="effect.future(_:)">
    <h3>
        <code>future(_:​)</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="function">future</span>(<span class="keyword">_</span> <span class="variable">attemptToFulfill</span>: <span class="attribute">@</span><span class="attribute">escaping</span> (<span class="attribute">@</span><span class="attribute">escaping</span> (<span class="type">Result</span>&lt;<span class="type">Output</span>, <span class="type">Failure</span>&gt;) -&gt; <span class="type">Void</span>) -&gt; <span class="type">Void</span>) -&gt; <a href="/Users/brandon/projects/swift-composable-architecture/Documentation/ComposableArchitecture/Effect"><span class="type">Effect</span></a></code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>Creates an effect that can supply a single value asynchronously in the future.</p>

</div>
<div class="discussion">
    <p>This can be helpful for converting APIs that are callback-based into ones that deal with
<code>Effect</code>s.</p>

<p>For example, to create an effect that delivers an integer after waiting a second:</p>

<html><body><pre class="highlight"><code><span class="variable">Effect</span>&lt;<span class="type">Int</span>, <span class="type">Never</span>&gt;.<span class="type">future</span> { <span class="variable">callback</span> <span class="keyword">in</span>
  <span class="variable">DispatchQueue</span>.<span class="type">main</span>.<span class="type">asyncAfter</span>(<span class="variable">deadline</span>: .<span class="variable">now</span>() + <span class="number literal">1</span>) {
    <span class="variable">callback</span>(.<span class="variable">success</span>(<span class="number literal">42</span>))
  }
}
</code></pre></body></html>
<p>Note that you can only deliver a single value to the <code>callback</code>. If you send more they will be
discarded:</p>

<html><body><pre class="highlight"><code><span class="variable">Effect</span>&lt;<span class="type">Int</span>, <span class="type">Never</span>&gt;.<span class="type">future</span> { <span class="variable">callback</span> <span class="keyword">in</span>
  <span class="variable">DispatchQueue</span>.<span class="type">main</span>.<span class="type">asyncAfter</span>(<span class="variable">deadline</span>: .<span class="variable">now</span>() + <span class="number literal">1</span>) {
    <span class="variable">callback</span>(.<span class="variable">success</span>(<span class="number literal">42</span>))
    <span class="variable">callback</span>(.<span class="variable">success</span>(<span class="number literal">1729</span>)) <span class="comment">// Will not be emitted by the effect</span>
  }
}
</code></pre></body></html>
<p>If you need to deliver more than one value to the effect, you should use the <code>Effect</code>
initializer that accepts a <code>Subscriber</code> value.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>attempt​ToFulfill</th>
    <td><code class="type">@escaping (@escaping (Result&lt;Output, Failure&gt;) -&gt; Void) -&gt; Void</code></td></td>
    <td><ul>
<li>attemptToFulfill: A closure that takes a <code>callback</code> as an argument which can be used to feed it <code>Result&lt;Output, Failure&gt;</code> values.</li>
</ul>
</td>
</tr>
  </tbody>
</table>
</div>
<div role="article" class="structure" id="effect.result(_:)">
    <h3>
        <code>result(_:​)</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="function">result</span>(<span class="keyword">_</span> <span class="variable">attemptToFulfill</span>: <span class="attribute">@</span><span class="attribute">escaping</span> () -&gt; <span class="type">Result</span>&lt;<span class="type">Output</span>, <span class="type">Failure</span>&gt;) -&gt; <span class="keyword">Self</span></code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>Initializes an effect that lazily executes some work in the real world and synchronously sends
that data back into the store.</p>

</div>
<div class="discussion">
    <p>For example, to load a user from some JSON on the disk, one can wrap that work in an effect:</p>

<html><body><pre class="highlight"><code><span class="variable">Effect</span>&lt;<span class="type">User</span>, <span class="type">Error</span>&gt;.<span class="type">result</span> {
  <span class="keyword">let</span> <span class="variable">fileUrl</span> = <span class="variable">URL</span>(
    <span class="variable">fileURLWithPath</span>: <span class="type">NSSearchPathForDirectoriesInDomains</span>(
      .<span class="variable">documentDirectory</span>, .<span class="variable">userDomainMask</span>, <span class="keyword">true</span>
    )[<span class="number literal">0</span>]
  )
  .<span class="type">appendingPathComponent</span>(<span class="string literal">"</span><span class="string literal">user.json</span><span class="string literal">"</span>)

  <span class="keyword">let</span> <span class="variable">result</span> = <span class="variable">Result</span>&lt;<span class="type">User</span>, <span class="type">Error</span>&gt; {
    <span class="keyword">let</span> <span class="variable">data</span> = <span class="keyword">try</span> <span class="variable">Data</span>(<span class="variable">contentsOf</span>: <span class="type">fileUrl</span>)
    <span class="keyword">return</span> <span class="keyword">try</span> <span class="variable">JSONDecoder</span>().<span class="type">decode</span>(<span class="variable">User</span>.<span class="keyword">self</span>, <span class="variable">from</span>: <span class="variable">$0</span>)
  }

  <span class="keyword">return</span> <span class="variable">result</span>
}
</code></pre></body></html>
</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>attempt​ToFulfill</th>
    <td><code class="type">@escaping () -&gt; Result&lt;Output, Failure&gt;</code></td></td>
    <td><ul>
<li>attemptToFulfill: A closure encapsulating some work to execute in the real world.</li>
</ul>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>An effect.</p>

</div>
<div role="article" class="structure" id="effect.run(_:)">
    <h3>
        <code>run(_:​)</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="function">run</span>(<span class="keyword">_</span> <span class="variable">work</span>: <span class="attribute">@</span><span class="attribute">escaping</span> (<a href="/Users/brandon/projects/swift-composable-architecture/Documentation/ComposableArchitecture/Effect"><span class="type">Effect</span></a>.<span class="type">Subscriber</span>&lt;<span class="type">Output</span>, <span class="type">Failure</span>&gt;) -&gt; <span class="type">Cancellable</span>) -&gt; <span class="keyword">Self</span></code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>Initializes an effect from a callback that can send as many values as it wants, and can send
a completion.</p>

</div>
<div class="discussion">
    <p>This initializer is useful for bridging callback APIs, delegate APIs, and manager APIs to the
<code>Effect</code> type. One can wrap those APIs in an Effect so that its events are sent through the
effect, which allows the reducer to handle them.</p>

<p>For example, one can create an effect to ask for access to <code>MPMediaLibrary</code>. It can start by
sending the current status immediately, and then if the current status is <code>notDetermined</code> it
can request authorization, and once a status is received it can send that back to the effect:</p>

<html><body><pre class="highlight"><code><span class="variable">Effect</span>.<span class="type">run</span> { <span class="variable">subscriber</span> <span class="keyword">in</span>
  <span class="variable">subscriber</span>.<span class="type">send</span>(<span class="variable">MPMediaLibrary</span>.<span class="type">authorizationStatus</span>())

  <span class="keyword">guard</span> <span class="variable">MPMediaLibrary</span>.<span class="type">authorizationStatus</span>() == .<span class="variable">notDetermined</span> <span class="keyword">else</span> {
    <span class="variable">subscriber</span>.<span class="type">send</span>(<span class="variable">completion</span>: .<span class="variable">finished</span>)
    <span class="keyword">return</span> <span class="variable">AnyCancellable</span> {}
  }

  <span class="variable">MPMediaLibrary</span>.<span class="type">requestAuthorization</span> { <span class="variable">status</span> <span class="keyword">in</span>
    <span class="variable">subscriber</span>.<span class="type">send</span>(<span class="variable">status</span>)
    <span class="variable">subscriber</span>.<span class="type">send</span>(<span class="variable">completion</span>: .<span class="variable">finished</span>)
  }
  <span class="keyword">return</span> <span class="variable">AnyCancellable</span> {
    <span class="comment">// Typically clean up resources that were created here, but this effect doesn't</span>
    <span class="comment">// have any.</span>
  }
}
</code></pre></body></html>
</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>work</th>
    <td><code class="type">@escaping (Effect.​Subscriber&lt;Output, Failure&gt;) -&gt; Cancellable</code></td></td>
    <td><ul>
<li>work: A closure that accepts a <code>Subscriber</code> value and returns a cancellable. When the <code>Effect</code> is completed, the cancellable will be used to clean up any resources created when the effect was started.</li>
</ul>
</td>
</tr>
  </tbody>
</table>
</div>
<div role="article" class="structure" id="effect.concatenate(_:)">
    <h3>
        <code>concatenate(_:​)</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="function">concatenate</span>(<span class="keyword">_</span> <span class="variable">effects</span>: <a href="/Users/brandon/projects/swift-composable-architecture/Documentation/ComposableArchitecture/Effect"><span class="type">Effect</span></a>) -&gt; <a href="/Users/brandon/projects/swift-composable-architecture/Documentation/ComposableArchitecture/Effect"><span class="type">Effect</span></a></code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>Concatenates a variadic list of effects together into a single effect, which runs the effects
one after the other.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>effects</th>
    <td><code class="type">Effect</code></td></td>
    <td><ul>
<li>effects: A variadic list of effects.</li>
</ul>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>A new effect</p>

</div>
<div role="article" class="structure" id="effect.concatenate(_:)">
    <h3>
        <code>concatenate(_:​)</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="function">concatenate</span>&lt;<span class="variable">C</span>: <span class="type">Collection</span>&gt;(<span class="keyword">_</span> <span class="variable">effects</span>: <span class="type">C</span>) -&gt; <a href="/Users/brandon/projects/swift-composable-architecture/Documentation/ComposableArchitecture/Effect"><span class="type">Effect</span></a> <span class="keyword">where</span> <span class="type">C</span>.<span class="type">Element</span> == <a href="/Users/brandon/projects/swift-composable-architecture/Documentation/ComposableArchitecture/Effect"><span class="type">Effect</span></a></code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>Concatenates a collection of effects together into a single effect, which runs the effects one
after the other.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>effects</th>
    <td><code class="type">C</code></td></td>
    <td><ul>
<li>effects: A collection of effects.</li>
</ul>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>A new effect</p>

</div>
<div role="article" class="structure" id="effect.merge(_:)">
    <h3>
        <code>merge(_:​)</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="function">merge</span>(<span class="keyword">_</span> <span class="variable">effects</span>: <a href="/Users/brandon/projects/swift-composable-architecture/Documentation/ComposableArchitecture/Effect"><span class="type">Effect</span></a>) -&gt; <a href="/Users/brandon/projects/swift-composable-architecture/Documentation/ComposableArchitecture/Effect"><span class="type">Effect</span></a></code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>Merges a variadic list of effects together into a single effect, which runs the effects at the
same time.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>effects</th>
    <td><code class="type">Effect</code></td></td>
    <td><ul>
<li>effects: A list of effects.</li>
</ul>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>A new effect</p>

</div>
<div role="article" class="structure" id="effect.merge(_:)">
    <h3>
        <code>merge(_:​)</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="function">merge</span>&lt;<span class="variable">S</span>: <span class="type">Sequence</span>&gt;(<span class="keyword">_</span> <span class="variable">effects</span>: <span class="type">S</span>) -&gt; <a href="/Users/brandon/projects/swift-composable-architecture/Documentation/ComposableArchitecture/Effect"><span class="type">Effect</span></a> <span class="keyword">where</span> <span class="type">S</span>.<span class="type">Element</span> == <a href="/Users/brandon/projects/swift-composable-architecture/Documentation/ComposableArchitecture/Effect"><span class="type">Effect</span></a></code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>Merges a sequence of effects together into a single effect, which runs the effects at the same
time.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>effects</th>
    <td><code class="type">S</code></td></td>
    <td><ul>
<li>effects: A sequence of effects.</li>
</ul>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>A new effect</p>

</div>
<div role="article" class="structure" id="effect.fireandforget(_:)">
    <h3>
        <code>fire​And​Forget(_:​)</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="function">fireAndForget</span>(<span class="keyword">_</span> <span class="variable">work</span>: <span class="attribute">@</span><span class="attribute">escaping</span> () -&gt; <span class="type">Void</span>) -&gt; <a href="/Users/brandon/projects/swift-composable-architecture/Documentation/ComposableArchitecture/Effect"><span class="type">Effect</span></a></code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>Creates an effect that executes some work in the real world that doesn't need to feed data
back into the store.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>work</th>
    <td><code class="type">@escaping () -&gt; Void</code></td></td>
    <td><ul>
<li>work: A closure encapsulating some work to execute in the real world.</li>
</ul>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>An effect.</p>

</div>
<div role="article" class="structure" id="effect.map(_:)">
    <h3>
        <code>map(_:​)</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">func</span> <span class="function">map</span>&lt;<span class="variable">T</span>&gt;(<span class="keyword">_</span> <span class="variable">transform</span>: <span class="attribute">@</span><span class="attribute">escaping</span> (<span class="type">Output</span>) -&gt; <span class="type">T</span>) -&gt; <a href="/Users/brandon/projects/swift-composable-architecture/Documentation/ComposableArchitecture/Effect"><span class="type">Effect</span></a>&lt;<span class="type">T</span>, <span class="type">Failure</span>&gt;</code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>Transforms all elements from the upstream effect with a provided closure.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>transform</th>
    <td><code class="type">@escaping (Output) -&gt; T</code></td></td>
    <td><ul>
<li>transform: A closure that transforms the upstream effect's output to a new output.</li>
</ul>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>A publisher that uses the provided closure to map elements from the upstream effect to new elements that it then publishes.</p>

</div>
<div role="article" class="structure" id="effect.cancellable(id:cancelinflight:)">
    <h3>
        <code>cancellable(id:​cancel​InFlight:​)</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">func</span> <span class="function">cancellable</span>(<span class="variable">id</span>: <span class="type">AnyHashable</span>, <span class="variable">cancelInFlight</span>: <span class="type">Bool</span> = <span class="keyword">false</span>) -&gt; <a href="/Users/brandon/projects/swift-composable-architecture/Documentation/ComposableArchitecture/Effect"><span class="type">Effect</span></a></code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>Turns an effect into one that is capable of being canceled.</p>

</div>
<div class="discussion">
    <p>To turn an effect into a cancellable one you must provide an identifier, which is used in
<code>Effect.cancel(id:)</code> to identify which in-flight effect should be canceled. Any hashable
value can be used for the identifier, such as a string, but you can add a bit of protection
against typos by defining a new type that conforms to <code>Hashable</code>, such as an empty struct:</p>

<html><body><pre class="highlight"><code><span class="keyword">struct</span> <span class="type">LoadUserId</span>: <span class="type">Hashable</span> {}

<span class="keyword">case</span> .<span class="variable">reloadButtonTapped</span>:
  <span class="comment">// Start a new effect to load the user</span>
  <span class="keyword">return</span> <span class="variable">environment</span>.<span class="type">loadUser</span>
    .<span class="variable">map</span>(<span class="variable">Action</span>.<span class="type">userResponse</span>)
    .<span class="variable">cancellable</span>(<span class="variable">id</span>: <span class="type">LoadUserId</span>(), <span class="variable">cancelInFlight</span>: <span class="keyword">true</span>)

<span class="keyword">case</span> .<span class="variable">cancelButtonTapped</span>:
  <span class="comment">// Cancel any in-flight requests to load the user</span>
  <span class="keyword">return</span> .<span class="variable">cancel</span>(<span class="variable">id</span>: <span class="type">LoadUserId</span>())
</code></pre></body></html>
</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>id</th>
    <td><code class="type">Any​Hashable</code></td></td>
    <td><ul>
<li>id: The effect's identifier.</li>
</ul>
</td>
</tr>
<tr>
    <th>cancel​InFlight</th>
    <td><code class="type">Bool</code></td></td>
    <td><ul>
<li>cancelInFlight: Determines if any in-flight effect with the same identifier should be canceled before starting this new one.</li>
</ul>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>A new effect that is capable of being canceled by an identifier.</p>

</div>
<div role="article" class="structure" id="effect.cancel(id:)">
    <h3>
        <code>cancel(id:​)</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="function">cancel</span>(<span class="variable">id</span>: <span class="type">AnyHashable</span>) -&gt; <a href="/Users/brandon/projects/swift-composable-architecture/Documentation/ComposableArchitecture/Effect"><span class="type">Effect</span></a></code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>An effect that will cancel any currently in-flight effect with the given identifier.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>id</th>
    <td><code class="type">Any​Hashable</code></td></td>
    <td><ul>
<li>id: An effect identifier.</li>
</ul>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>A new effect that will cancel any currently in-flight effect with the given identifier.</p>

</div>
<div role="article" class="structure" id="effect.debounce(id:for:scheduler:options:)">
    <h3>
        <code>debounce(id:​for:​scheduler:​options:​)</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">func</span> <span class="function">debounce</span>&lt;<span class="variable">S</span>: <span class="type">Scheduler</span>&gt;(<span class="variable">id</span>: <span class="type">AnyHashable</span>, <span class="variable">for</span> <span class="variable">dueTime</span>: <span class="type">S</span>.<span class="type">SchedulerTimeType</span>.<span class="type">Stride</span>, <span class="variable">scheduler</span>: <span class="type">S</span>, <span class="variable">options</span>: <span class="type">S</span>.<span class="type">SchedulerOptions</span>? = <span class="keyword">nil</span>) -&gt; <a href="/Users/brandon/projects/swift-composable-architecture/Documentation/ComposableArchitecture/Effect"><span class="type">Effect</span></a></code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>Turns an effect into one that can be debounced.</p>

</div>
<div class="discussion">
    <p>To turn an effect into a debounce-able one you must provide an identifier, which is used to
determine which in-flight effect should be canceled in order to start a new effect. Any
hashable value can be used for the identifier, such as a string, but you can add a bit of
protection against typos by defining a new type that conforms to <code>Hashable</code>, such as an empty
struct:</p>

<html><body><pre class="highlight"><code><span class="keyword">case</span> <span class="keyword">let</span> .<span class="variable">textChanged</span>(<span class="variable">text</span>):
  <span class="keyword">struct</span> <span class="type">SearchId</span>: <span class="type">Hashable</span> {}

  <span class="keyword">return</span> <span class="variable">environment</span>.<span class="type">search</span>(<span class="variable">text</span>)
    .<span class="type">map</span>(<span class="variable">Action</span>.<span class="type">searchResponse</span>)
    .<span class="type">debounce</span>(<span class="variable">id</span>: <span class="type">SearchId</span>(), <span class="variable">for</span>: <span class="number literal">0.5</span>, <span class="variable">scheduler</span>: <span class="type">environment</span>.<span class="type">mainQueue</span>)
</code></pre></body></html>
</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>id</th>
    <td><code class="type">Any​Hashable</code></td></td>
    <td><ul>
<li>id: The effect's identifier.</li>
</ul>
</td>
</tr>
<tr>
    <th>due​Time</th>
    <td><code class="type">S.​Scheduler​Time​Type.​Stride</code></td></td>
    <td><ul>
<li>dueTime: The duration you want to debounce for.</li>
</ul>
</td>
</tr>
<tr>
    <th>scheduler</th>
    <td><code class="type">S</code></td></td>
    <td><ul>
<li>scheduler: The scheduler you want to deliver the debounced output to.</li>
</ul>
</td>
</tr>
<tr>
    <th>options</th>
    <td><code class="type">S.​Scheduler​Options?</code></td></td>
    <td><ul>
<li>options: Scheduler options that customize the effect's delivery of elements.</li>
</ul>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>An effect that publishes events only after a specified time elapses.</p>

</div>
<div role="article" class="structure" id="effect.timer(id:every:tolerance:on:options:)">
    <h3>
        <code>timer(id:​every:​tolerance:​on:​options:​)</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="function">timer</span>&lt;<span class="variable">S</span>&gt;(<span class="variable">id</span>: <span class="type">AnyHashable</span>, <span class="variable">every</span> <span class="variable">interval</span>: <span class="type">S</span>.<span class="type">SchedulerTimeType</span>.<span class="type">Stride</span>, <span class="variable">tolerance</span>: <span class="type">S</span>.<span class="type">SchedulerTimeType</span>.<span class="type">Stride</span>? = <span class="keyword">nil</span>, <span class="variable">on</span> <span class="variable">scheduler</span>: <span class="type">S</span>, <span class="variable">options</span>: <span class="type">S</span>.<span class="type">SchedulerOptions</span>? = <span class="keyword">nil</span>) -&gt; <a href="/Users/brandon/projects/swift-composable-architecture/Documentation/ComposableArchitecture/Effect"><span class="type">Effect</span></a> <span class="keyword">where</span> <span class="type">S</span>: <span class="type">Scheduler</span>, <span class="type">S</span>.<span class="type">SchedulerTimeType</span> == <span class="type">Output</span></code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>Returns an effect that repeatedly emits the current time of the given
scheduler on the given interval.</p>

</div>
<div class="discussion">
    <p>This effect serves as a testable alternative to <code>Timer.publish</code>, which
performs its work on a run loop, <em>not</em> a scheduler.</p>

<html><body><pre class="highlight"><code><span class="keyword">struct</span> <span class="type">TimerId</span>: <span class="type">Hashable</span> {}

<span class="keyword">switch</span> <span class="variable">action</span> {
<span class="keyword">case</span> .<span class="variable">startTimer</span>:
  <span class="keyword">return</span> <span class="variable">Effect</span>.<span class="type">timer</span>(<span class="variable">id</span>: <span class="type">TimerId</span>(), <span class="variable">every</span>: <span class="number literal">1</span>, <span class="variable">on</span>: <span class="type">environment</span>.<span class="type">scheduler</span>)
    .<span class="type">map</span> { .<span class="variable">timerUpdated</span>(<span class="variable">$0</span>) }
<span class="keyword">case</span> <span class="keyword">let</span> .<span class="variable">timerUpdated</span>(<span class="variable">date</span>):
  <span class="type">state</span>.<span class="type">date</span> = <span class="variable">date</span>
  <span class="keyword">return</span> .<span class="variable">none</span>
<span class="keyword">case</span> .<span class="variable">stopTimer</span>:
  <span class="keyword">return</span> .<span class="variable">cancel</span>(<span class="variable">id</span>: <span class="type">TimerId</span>())
</code></pre></body></html>
</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>interval</th>
    <td><code class="type">S.​Scheduler​Time​Type.​Stride</code></td></td>
    <td><ul>
<li>interval: The time interval on which to publish events. For example, a value of <code>0.5</code> publishes an event approximately every half-second.</li>
</ul>
</td>
</tr>
<tr>
    <th>scheduler</th>
    <td><code class="type">S</code></td></td>
    <td><ul>
<li>scheduler: The scheduler on which the timer runs.</li>
</ul>
</td>
</tr>
<tr>
    <th>tolerance</th>
    <td><code class="type">S.​Scheduler​Time​Type.​Stride?</code></td></td>
    <td><ul>
<li>tolerance: The allowed timing variance when emitting events. Defaults to <code>nil</code>, which allows any variance.</li>
</ul>
</td>
</tr>
<tr>
    <th>options</th>
    <td><code class="type">S.​Scheduler​Options?</code></td></td>
    <td><ul>
<li>options: Scheduler options passed to the timer. Defaults to <code>nil</code>.</li>
</ul>
</td>
</tr>
  </tbody>
</table>
</div>
<div role="article" class="structure" id="effect.async(_:)">
    <h3>
        <code>async(_:​)</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="attribute">@</span><span class="attribute">available</span>(*, <span class="variable">deprecated</span>, <span class="variable">renamed</span>: <span class="string literal">"run"</span>) <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="function">async</span>(<span class="keyword">_</span> <span class="variable">work</span>: <span class="attribute">@</span><span class="attribute">escaping</span> (<a href="/Users/brandon/projects/swift-composable-architecture/Documentation/ComposableArchitecture/Effect"><span class="type">Effect</span></a>.<span class="type">Subscriber</span>&lt;<span class="type">Output</span>, <span class="type">Failure</span>&gt;) -&gt; <span class="type">Cancellable</span>) -&gt; <span class="keyword">Self</span></code></pre></body></html>
</div>
<div role="article" class="structure" id="effect.throttle(id:for:scheduler:latest:)">
    <h3>
        <code>throttle(id:​for:​scheduler:​latest:​)</code>
    </h3>
    <html><body><pre class="highlight"><code><span class="keyword">func</span> <span class="function">throttle</span>&lt;<span class="variable">S</span>&gt;(<span class="variable">id</span>: <span class="type">AnyHashable</span>, <span class="variable">for</span> <span class="variable">interval</span>: <span class="type">S</span>.<span class="type">SchedulerTimeType</span>.<span class="type">Stride</span>, <span class="variable">scheduler</span>: <span class="type">S</span>, <span class="variable">latest</span>: <span class="type">Bool</span>) -&gt; <a href="/Users/brandon/projects/swift-composable-architecture/Documentation/ComposableArchitecture/Effect"><span class="type">Effect</span></a> <span class="keyword">where</span> <span class="type">S</span>: <span class="type">Scheduler</span></code></pre></body></html>
<div class="summary" role="doc-abstract">
    <p>Turns an effect into one that can be throttled.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>id</th>
    <td><code class="type">Any​Hashable</code></td></td>
    <td><ul>
<li>id: The effect's identifier.</li>
</ul>
</td>
</tr>
<tr>
    <th>interval</th>
    <td><code class="type">S.​Scheduler​Time​Type.​Stride</code></td></td>
    <td><ul>
<li>interval: The interval at which to find and emit the most recent element, expressed in the time system of the scheduler.</li>
</ul>
</td>
</tr>
<tr>
    <th>scheduler</th>
    <td><code class="type">S</code></td></td>
    <td><ul>
<li>scheduler: The scheduler you want to deliver the throttled output to.</li>
</ul>
</td>
</tr>
<tr>
    <th>latest</th>
    <td><code class="type">Bool</code></td></td>
    <td><ul>
<li>latest: A boolean value that indicates whether to publish the most recent element. If <code>false</code>, the publisher emits the first element received during the interval.</li>
</ul>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>An effect that emits either the most-recent or first element received during the specified interval.</p>

</div>
    </section>



        </article>
    </main>

    <footer>
        <p>
    Generated on <time datetime="2020-05-27T09:38:58-0700">May 27, 2020</time> using <a href="https://github.com/SwiftDocOrg/swift-doc">swift-doc</a> <span class="version">1.0.0-beta.2</span>.
</p>
    </footer>
</body>
</html>
